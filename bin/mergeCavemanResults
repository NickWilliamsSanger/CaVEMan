#! /usr/bin/perl

########## LICENSE ##########
# Copyright (c) 2014 Genome Research Ltd. 
# 
# Author: Cancer Genome Project cgpit@sanger.ac.uk 
# 
# This file is part of caveman_c. 
# 
# caveman_c is free software: you can redistribute it and/or modify it under 
# the terms of the GNU Affero General Public License as published by the Free 
# Software Foundation; either version 3 of the License, or (at your option) any 
# later version. 
# 
# This program is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more 
# details. 
# 
# You should have received a copy of the GNU Affero General Public License 
# along with this program. If not, see <http://www.gnu.org/licenses/>. 
# 
###########################

use strict;
use warnings FATAL=>'all';

use Getopt::Long;
use Pod::Usage qw(pod2usage);
use Carp;

{
	my $options = setup();

	my $OUT;
	open($OUT,'>',$options->{'o'}.".tmp") or die("Error opening output file $options->{o}.tmp for write: $!\n");
		#Iterate through each file
		my $have_head = 0;
		my $head;
		foreach my $filename(@{$options->{'files'}}){
			#open file
			my $IN;
			open($IN, '<', $filename) or die("Error trying to open $filename for read: $!\n");
				my $tmp_head;
				while(<$IN>){
					my $line = $_;
					if($line =~ m/^#/){
						if($have_head == 0){
							push (@$head, $line);
						}else{
							#Check our header matched that previously passed in.
							push (@$tmp_head, $line);
							#Now check against our stored header.
							for(my $i=0; $i<scalar(@$tmp_head); $i++){
								next if($tmp_head->[$i] =~ m/fileDate/);
								if($tmp_head->[$i] ne $head->[$i] ){
									croak("Header mismatch found at line ",($i+1),
													" of header:\n",$tmp_head->[$i]," ne ",$head->[$i],"\n");
								}
							}
						}
						next;
					}elsif($have_head==0){
						$have_head = 1;
						foreach my $head_line(@$head){
							print $OUT $head_line;
						}
						next;					
					} # End of header check.					
				
					print $OUT $line;
								
				}	# End of iterating through this file.	
			close($IN);
		}
	close ($OUT);

	# We've written a tmp file with all results, now take the header, 
	# and sort the remaining entries into the proper output file.
	
	# Get the header into the file.
	my $head_cmd = "grep -e '^#' ".$options->{'o'}.".tmp > ".$options->{'o'};
	`$head_cmd`;
	
	# Get the non header lines and sort accordingly
	my $non_head_sort_cmd = "grep -ve '^#' ".$options->{'o'}.".tmp | sort -k1,1 -k2,2n >> ".$options->{'o'};
	`$non_head_sort_cmd`;
	
	# delete the tmp file
	unlink($options->{'o'}.".tmp") or die("ERROR: Couldn't delete temporary output  file ".$options->{'o'}.".tmp".":$!");
}

sub setup{
	my %opts;
  	GetOptions( 'h|help' => \$opts{'h'},
					'o|output=s' => \$opts{'o'},
  	) or pod2usage(2);
  
	if($opts{'h'}){
  		pod2usage(0);
	}
	
	pod2usage(-msg  => "\nERROR: Incorrect parameters.\n", -verbose => 2, -output => \*STDERR ) unless($opts{'o'});
	
	$opts{'files'} = \@ARGV;
	
	return \%opts;
}

__END__

=head1 NAME

mergeCavemanResults - Perl script to merge VCF or BED format results files output by CaVEMan split jobs 
                      into a single results file. 
                      For example mergeCavemanResults -t vcf -o muts.vcf results/*/*.muts.vcf

=head1 SYNOPSIS

mergeCavemanResults [options] [file(s)...]

Required parameters:
    --output       -o   File to output result to.

Other:
    --help         -h   Brief help message.

=head1 DESCRIPTION

B<mergeCavemanResults> Will merge CaVEMan split output files into a single result file for the type. 
    
=cut